% -*-coding: utf-8 -*-
\ifx\atempxetex\usewhat 
\XeTeXinputencoding "utf-8"
\fi
\defaultfont

\chapter{简介和主要概念}

摆在你面前的是一本关于系统编程的书，你将在本书中学习到编写系统软件的相关技术和技巧。系统软件运行于系统的底层，与内核和系统核心库直接进行交互。常见的系统软件包括shell、文本编辑器、编译器、调试器、核心工具(译者注:即GNU Core Utilities, 是构成GNU系统的基本工具集，包括大部分我们常用的命令)和系统守护进程等。这些程序都是基于内核和C库完成，可以称为"纯"系统软件。其余大部分软件（如高层(high-level)GUI应用程序）则运行在更高的层次，在必要情况下，它们也会和底层直接交互。有些程序员花费整天整夜的时间编写系统软件，而有些人则很少。不管是谁，深入理解系统编程都令程序员受益匪浅。无论你把它当作是制胜的法宝，还是仅仅认为是更高层概念的基础，系统编程都是我们编写的软件的关键所在。


确切的说，这是一本关于Linux上的系统编程的书。Linux是Linus Torvalds和全球范围内松散的黑客组织写的类Unix现代操作系统。尽管Linux和Unix有着共同的目标和理念，但是Linux不是Unix，Linux遵循自己的原则，关注方方面面的需求，专注于实用功能的开发。总的来说，Linux系统编程的核心内容和任何其它的Unix系统都是一样的。然而，除了基本内容外，Linux相比于传统的Unix系统还拥有自己突出的特点，Linux还拥有大量的新增的系统调用，不同的行为和新特性。 

\section{系统编程}
从传统的角度讲，所有的Unix编程都是系统级别编程。这是因为在历史上，Unix系统并没有很多的高级抽象，甚至在X Window系统上进行开发工作时，我们也会接触到大量的Unix核心API。因此，可以说这本书基本上是介绍Linux程序设计的。然而，这本书并不包含系统编程环境的介绍--书中没有任何关于make的指南，它只涵盖现代Linux机器上所使用的系统编程的API。

人们常常拿系统编程和应用层编程相比，它们有不同点，也有共同点。系统编程最突出的特点是要求系统程序员必须对它工作的系统的硬件和操作系统有深入和全面的了解，当然它们还有库和系统调用上的区别。如果从编写的应用的运行层次上来看，这两者基本上没有相关的内容。但是，总的来说，从应用程序编程转移到系统编程(或者相反),都并不是一件很困难的事情。就算是应用运行于较高层次，远离系统的最底层，系统编程的知识依然是很重要的，好的方法在各种形式的编程中都同样受用。

在近几年，我们都目睹着这样一个趋势：不管是web软件（如Javascript，PHP）还是通过托管代码（如C\#或者Java）应用编程越来越远离系统编程而向着更高的层次发展。然而，这个发展并不是预示着系统编程的消亡。实际上，还有人在继续编写Javascript解析器和C\#运行支持库，而这些都是系统编程。更进一步讲，PHP和Java程序员依然可以从系统编程中受益，就如同深入理解核内部的人能在任何层次都写出更好的代码。

尽管应用编程的发展趋势如此，大部分的Unix和Linux的程序依然是系统级别编程，这其中多数为C，且基于C库和内核提供的接口。这就是传统的系统编程——Apache、 bash、cp、Emacs、init、gcc、gdb、glibc、ls、mv、vim和X，这些应用都不会很快过时的。

在系统编程的分支中，通常包括内核开发，或者至少有设备驱动的内容。但是这本书和多数系统编程的书籍一样，将不讨论内核开发。这本书将专注于所有内核之上的内容（尽管内核知识对本书很有裨益）——用户空间系统级别编程。同样，网络编程——套接字以及相关的内容——也不在本书中展开讨论。设备驱动编程和网络编程都是很宽泛的主题，已经有许多经典书籍讨论这些话题了。

什么是系统级应用接口？我怎样在Linux上编写系统级别应用程序？内核和C库到底提供了些什么？我如何优化代码？Linux还设计了什么小伎俩？相比于其它Unix版本，Linux提供了哪些巧妙的系统调用？它们是如何工作的？这些问题将在接下来的章节中一一讨论。

系统编程中有三大基石：系统调用，C库和C编译器，每一个值得好好的介绍一下。 

\subsection{系统调用}
系统编程始于系统调用。系统调用（通常简写为syscalls）是为了从操作系统获得服务或者资源而从用户空间——如文本编辑器，游戏等等——向内核（系统的核心）发起的函数调用。系统调用范围很广，从我们熟悉的read()和write()函数到少见的get\_thread\_area()和 set\_tid\_address()。

Linux实现的系统调用数量远远少于大部分其它操作系统。举例来说，i386架构的系统调用大概在300个左右，相比而言，微软的 Windows声称上千个。在Linux的内核中，每一个机器架构（如Alpha，i386，PowerPC)都实现了各自的系统调用。因此，不同架构之间的系统调用存在着一定的区别。然而，90\%以上系统调用在所有的架构上都实现了。本书上所讨论的正好是这个公共部分的内容。 

\subsection{调用系统调用}

用户空间应用程序不可能直接访问内核。基于系统安全和稳定的考虑，用户空间程序禁止直接执行内核的代码或者操作内核数据。相反，内核必须提供这样一个机制，用户空间程序能够发送信号通知内核它希望调用一个系统调用。这个应用程序因此能够通过这一机制深入到内核中，执行那些内核允许执行的代码。这个机制在不同的机器各不相同，例如，在i386上，用户空间程序执行参数为0x80的中断指令int，这个指令触发系统将当前运行环境切换到内核的保护区域，内核执行终端处理函数的区域——但是什么是中断0x80的处理函数呢？除了这个系统外，没有别的系统调用处理函数。

应用程序通过机器寄存器通知内核执行哪一个系统调用，带什么参数。系统调用通过数字标注，从0开始。在i386架构上，要想请求系统调用5（正好是open()），用户空间程序必须在使用int指令前将5填写到eax寄存器中。

参数传递也通过类似的方式进行处理。还是以i386为例，寄存器被用于每一个可能的参数——寄存器ebx、ecx、edx、esi和edi顺序存储前5个参数。对于一些少见的超过5个参数的系统调用，使用一个的寄存器指向用户空间中存储所有参数的缓存区即可。当然，大部分系统调用仅有少数的参数。

其它架构处理系统调用的方式不同，但是基本的精神是一致的。作为一个系统程序员，你通常不需要知道内核是怎样处理系统调用的。这部分内容已经成为系统架构的标准调用惯例的一部分，并通过编译器和C库自动处理。 

\subsection{C库}

C库（libc）是Unix应用程序的核心。就算你使用别的语言，C库也常常扮演着重要的角色，它常被高级的库封装，提供核心服务或者方便的系统调用。在现代的Linux系统中，C库由GNU libc提供，简称为glibc，发音是[gee-lib-see]或者更短点[glib-see].

GNU C库提供了远超过其名字所展示的内容。除了标准的C库，glibc还提供了系统调用封装，线程支持和基本应用工具。 

\subsection{C编译器}
在Linux中，标准的C编译器是GNU编译器工具集（gcc）。原先，gcc是GNU版本的cc，C编译器。因此，GCC表示GNU C Compiler。后来，越来越多的语言支持都添加进去了。时至今日，gcc成了GNU编译器家族的代名词。然而，gcc经常被用来调用C编译器，在这本书中，当我讨论到gcc的时候，如果没有指定上下文，指的是gcc应用程序。


因为编译器辅助实现了C标准(参阅"C语言标准")和系统的ABI(参阅"APIs和ABIs"一节)，因此Unix系统(包括Linux系统)中的编译器和系统编程的联系非常紧密。 

\section{API和ABI}
无论现在还是将来，程序员们都希望它们写的程序可以运行在所有声称提供支持的系统上。它们希望在它们自己的Linux发行版上完成的程序也能够运行于其它的Linux发行版，同时还可以运行在其它Linux支持的架构和更新的Linux版本上。

在系统级别，影响可移植性的因素主要包括两个相互独立的定义和描述集合，一个是应用程序接口（API）另一个是应用程序二进制接口（ABI），两个都定义和描述了软件不同模块间的接口。 

\subsection{API}
API定了软件模块之间在源代码层交互的接口。它通过提供一组标准接口(通常以函数的方式)的方式进行抽象:一个程序片段（一般是较高层次的代码，但不见得一定是）可以调用另一个程序片段（通常位于较低层次）。举例来说，一个在屏幕上显示文本的API可能是对一系列显示文本函数提炼而得来的。一个API仅仅定义接口，而我们经常说的“API”其实是对API的实现。

通常人们把API称为一个“约定”，这不大合理，至少从该术语的一般含义上来讲，API并非双向协议。API的用户(一般是高层软件)并没有给API的定义和实现提供任何实质内容，你只能按照它现在的样子使用它，或者不使用它：要或者不要，仅此而已。API所做的仅仅是在两个软件都遵循同样的API时，确保源代码兼容。也就是说，API用户在该API的实现上能成功编译。

现实中的例子是API通过C标准来定义且通过C库来实现，这些API定义了一系列基本和重要的函数，例如字符串处理函数。

在这本书中，我们经常会涉及到API，例如第三章讨论的标准I\/O。Linux系统编程中最重要的API将在本章的“标准”一节中讨论。 



\subsection{ABI}
API定义了源代码接口，而ABI定义的则是在特定的架构上两个或者多个软件模块之间的二进制接口。它定义了一个应用如何和自己交互，如何和内核以及库进行交互。ABI必须保证二进制代码兼容，保证一段目标代码能够在任何具有同样ABI的系统上都正常运作，而不需要重新编译。

ABI主要关注的问题有调用约定、字节序、寄存器使用、系统调用、链接、库行为和二进制格式。以调用规则为例，它规定了函数如何被调用，参数如何传递，哪些寄存器被保留而哪些会被破坏，以及调用者如何提取返回的结果。

尽管曾经尝试着为特定架构下不同的操作系统（特别是i386上的Unix操作系统）定义唯一的ABI，然而到目前为止还没有取得成效。相反，包括Linux在内的操作系统都尝试定义各自独立的ABI，这些 ABI和架构紧密相连。大部分的ABI涉及了机器级别的概念，如特定的寄存器或者汇编指令。因此，在Linux系统中，每一个机器架构都有自己的ABI集合，事实上，我们以机器架构的名称来称呼这些ABI，例如alpha，x86-64等。

系统编程需要有ABI的意识，但是却没有必要记住它。因为ABI没有表面上的接口，而是通过工具链（tooltrain）如编译器、链接器等来执行。但是，了解ABI的相关内容，可以帮助你写出更优化的代码，也是你编写汇编代码或者研究工具链时的绝好资料（其实，这也是系统编程）。

我们可以从互联网上获得Linux上特定架构的工具链和内核实现的ABI资料。 

\section{标准}
Unix系统编程是门古老的艺术，Unix编程基础已经多年没有变动了。但是Unix还是像一头精力充沛的野兽。其行为在不断变化，特性不断增加。为了让这个混乱的世界变得有序，标准组织将系统接口标准化并建立官方标准。众多的标准保留了下来，但是，从技术上讲，Linux并没有遵循它们。 Linux仅力图和两个最广泛使用的标准保持兼容：POSIX和Single Unix Specification(SUS)

除了其它内容，POSIX和SUS定义了类Unix操作系统接口上的C API，它们有效的为各种兼容的Unix系统定义了系统编程，至少是从其中归纳出了通用的API集。

\subsection{POSIX和SUS的历史}
在1980年中期，电气电子工程师协会（IEEE）首先开始了Unix系统的系统级别接口标准化的相关工作。自由软件运动（Free Software Movement）的创始人Richard Stallman建议使用POSIX为该标准（发音pahz-icks），其全称为Portable Operating System Interface（可移植操作系统接口）。

在1988年，这些努力开始有了成果，IEEE std 1003.1-1988（简称POSIX1988）通过。1990年，IEEE修订 POSIX标准形成了IEEE std 1003.1-1990（POSIX1990）。非强制性的实时和线程支持则在IEEE Std 1003.1b-1993 (POSIX 1993 or POSIX.1b)和IEEE Std 1003.1c-1995(POSIX 1995 or POSIX.1c)正式成文。2001年，这些非强制性标准在POSIX1990的基础上整合形成单一的标准：IEEE Std 1003.1-2001 (POSIX 2001)。最新的标准IEEE Std 1003.1-2004发布于2004年4月，所有的核心POSIX标准简称为POSIX.1，以2004年版本为最新版本。

在1980年后期到1990年初期，Unix系统的厂商卷入了一场"Unix战争"中，每个厂商都处心积虑的将各自的Unix变种定义为"Unix"。几个主要的Unix厂商通过合并Open Software Foundation（OSF）和X/Open组建了工业联盟-The Open Group。The Open Group提供认证、白皮书和兼容测试。在1990早期，当Unix战争正如火如荼的时候，The Open Group发布了“单一UNIX规范”（Single UNIX Specification，SUS）。相比于高成本的POSIX标准，SUS是免费的，因此广受欢迎。今天，SUS已经合并了最新的POSIX标准。

第一个版本的SUS发布于1994年，与SUSv1兼容的系统被标记为Unix 95. 第二个版本的SUS发布于1997年，相应的兼容系统称为UNIX 98.第三个版本的SUS，也是最新的SUS,SUSv3发布于2002年，兼容的系统标记为Unix 03.SUSv3修正和合并了IEEE Std 1003.1-2001 和其它几个标准。在这本书中，我将在被POSIX标准化的系统调用和其它接口中提及。我将提及POSIX而不是SUS因为后者包含了前者（译者注：SUS是POSIX.1标准的一个超集，定义了一些附加的接口，这些接口扩展了基本的POSIX.1规范所提供的功能--APUE S2.2.3）。 

\subsection{C语言标准}
Dennis Ritchie和Brian Kernighan的经典著作《C程序设计语言》(Prentice Hall)自1978年首次出版后，一直扮演着非正式的C语言规范的角色。这个版本的C俗称K\&R C。C已经快速的代替了Basic而成为了微型计算机编程的通用语言。因此，为了对这个在那时已经相当流行的语言进行标准化，美国国家标准化学院（ANSI）在1983成立了一个委员会开发一个官方版本的C语言，该版本博采众家之长，引进了新的特性，同时还借鉴了C++语言的一些经验。这个过程艰苦而漫长，ANSI C最终在1989年顺利完成。 1990年，国际标准化组织（ISO）基于ANSI C进行了少数修改，批准了ISO C90。

在1995年，ISO 发布了一个新版标准（虽然很少被执行），命名为ISO C95。1999年的版本ISO C99更新了大量的内容，引进了很多新的特征，包括inline函数、新数据类型、变长数组、C++风格注释和新的库函数。 

\subsection{Linux和标准}

如前所述，Linux旨在和POSIX以及SUS兼容，它提供了SUSv3和POSIX.1描述的接口，包括可选的实时（POSIX.1b)和线程 (POSIX.1c)支持。更重要的是，Linux尝试着提供和POSIX和SUS要求一致的行为。总之，无法满足标准的部分即被视为bug。Linux 被认为是按照POSIX.1和SUSv3实现的，但没有经过POSIX或者SUS官方认证（特别是Linux的每个修订），所以我无法正式宣布Linux是POSIX或者SUS兼容的。


关于语言标准，Linux很幸运，gcc C编译器支持ISO C99，另外，gcc提供了很多C语言的扩展，这些扩展统称为GNU C。附录中有相关描述。

Linux没有很好的向前兼容的历史，不过这些日子过得还算顺利。标准C库这样被标准描述的接口将明显的继续保持源代码兼容。二进制代码兼容至少可以通过主要的glibc版本来维持。尽管某些gcc扩展遭到反对甚至在新的gcc发布范本中被删除，但是因为C语言已经标准化，gcc将始终准确的编译合法的C程序。最重要的是，Linux内核保证系统调用的稳定，一旦系统调用在Linux内核的稳定版本上实现，那就不会再改变了。

在不同的Linux发布版中，大部分被Linux基本规范（LSB）所标准化。LSB是在Linux基金会（前身是自由标准组织 [Free Standard Group])赞助下由几个厂商负责的联合项目。LSB扩展了POSIX和SUS，添加了自己的标准。它尝试提供二进制标准，从而允许目标代码无需修改即可在兼容的系统上运行。大部分Linux厂商都在一定程度上遵循了LSB标准。

\subsection{本书和标准}

本书有意避免关于任何标准的空话。大多数时候，Unix系统编程书籍必须停止对不同标准的接口的表现进行口舌之争，无论给定的系统调用是在哪个系统上实现，都不要再浪费大量篇幅进行讨论。本书仅涉及在最新版本的2.6内核、gcc 4.2编译器和C库（2.5）的Linux系统上的进行系统编程的相关知识。

因为系统接口通常是固定的(Linux内核开发人员需要小心处理，以避免破坏调用接口) ，同时系统接口还提供了一定程度上源码和二进制码的兼容性，这种方式允许我们深入Linux细节的时候，不必去关心与其它Unix系统和标准的兼容性问题。将讨论的重点放在Linux上使本书可以深入探讨最前沿的，且在未来将继续使用的Linux接口。本书详尽地介绍了Linux系统的相关细节，特别是gcc，内核等模块的实现和行为。让我们可以从专业视角洞悉高手的实践能力和优化技巧。 


\section{Linux编程概念}
这一节主要展现一个关于Linux环境提供的服务的简要概览。所有的Unix系统，包括Linux系统，都提供了一个共同的抽象和接口集合。事实上，这个共同点定义了Unix。如对文件和进程的抽象、管道和套接字管理的接口等等，都是Unix的核心内容。

这个概览假定你已经熟悉了Linux环境：可以熟练使用shell，使用基本命令，编译简单的C程序。这些并不是Linux的概览，也不是Linux编程环境的内容，而是进行Linux系统编程的最基本的知识。

\subsection{文件和文件系统}

文件是Linux中最基本和重要的抽象。Linux遵循一切皆是文件的理念（虽然并不是像某些其它系统那么严格，如Plan9）。因此，很多的交互工作是通过读取和写入文件来完成，就算问题的目标并不是你日常所想的文件。

文件必须被打开才能被访问。文件可以以只读方式或者只写方式打开，或者两者兼有。一个打开的文件通过唯一的文件描述符进行引用，该描述符是打开文件的元数据至其本身的映射。在Linux内核中，这个描述符称为文件描述符，用一个整数表示（C语言中的类型为int），简写为fd。文件描述符在用户空间中共享，允许用户程序用文件描述符直接访问文件。大部分的Linux系统编程包括对文件描述符的打开，关闭等操作。

\subsubsection{普通文件}

我们常常说起的文件，就是Linux中的普通文件。一个普通文件包含以线性字节数组方式组织的数据，通常也称为字节流。在Linux中，文件没有更进一步的组织结构或者格式。字节可以是任何值，也可以以任何方式被组织在一个文件中，在系统级别，除了字节流，Linux并没有要求文件有特定的结构。某些操作系统，如VMS，提供了高度结构化的文件，支持如记录这样的概念。Linux并没有做这样的处理。

文件中的任何字节都可以被读或者写，这些操作开始于特定的字节，也就是文件中所谓的“地址”的概念。这个地址就是文件位置或者文件偏移量。这个文件位置是内核与每一个打开的文件关联的元数据非常重要的一部分。当文件首次打开时，位置为0。通常，随着对文件的读写操作(按字节进行)，文件的位置也随之增长。文件的位置也可以通过手工指定一个值，就算这个值超过了文件的结尾。在超过文件结尾之后写入字节将会导致中间的字节填充为0。尽管可以通过这样的方式在文件的末尾写入字节，但是却不允许在文件的头部之前写入字节。这种情况听上去很荒谬，实际上也没多大用处。文件位置起始于0，它不可能是负数。在文件中间写入字节将覆盖位置偏移量上的值。因此，通过在中间写入内容来扩展文件是不可行的，大部分文件写操作发生在文件的结尾，文件位置的最大值只受存储该值的 C语言类型的大小所限制，在最新的版本的Linux上是64位。

文件的大小通过字节来计算，称为文件长度。文件长度，就是组成文件的线性数组里字节的数目。文件的长度可以通过截断（truncation）来改变。一个文件可以通过删除文件结尾部分而截短为稍小的文件。令人困惑的是，根据截断操作这个名字，一个文件可以被截断成比原来更大的文件。在这种情况，文件以“0”进行填充（在文件的末尾）。文件可以为空（长度为0），不包含任何可用字节。文件最大值，如同文件位置的最大值，受限于Linux内可用于管理文件的C语言类型的大小。然而，某些特定的文件系统，也可能强加自己的限制，将最大值限定在更小的值。

同一个文件能被不同或者相同的进程多次打开，系统为每一个打开文件的实例提供唯一的文件描述符。进程能够共享文件描述符，从而允许同一描述符被多个进程使用。内核并没有对并发文件访问强加任何限制，不同的进程能够同时对同一个文件进行读写。并发访问的结果取决于独立操作的顺序，且通常是不可预测的。用户空间程序必须调整它们自己的顺序以保证并发文件访问可以同步。

文件通过文件名进行访问，但事实上，对于文件本身并不与文件名称直接关联。相反，文件通过inode（信息节点）来访问，inode使用唯一的数值进行标志。该值称为inode编号(inode number)，通常简写为i-number或者ino。一个inode存储文件关联的元数据，如它的修改时间戳、所有者、类型、长度以及文件的数据的地址--唯独没有文件名。inode既是Unix文件系统在磁盘上实际物理对象，也是Linux内核中的数据结构的概念实体。

\subsubsection{目录和链接}

通过inode编号来访问文件显然是一个不明智的决定（也是一个潜在的安全漏洞）。因此，人们经常使用文件名来访问文件。目录就是用来提供访问文件时所需的名字的，目录将易读的名字和inode编号进行映射。名字与inode的配对，称为链接（link）。映射在物理磁盘上的形式，可以是一个简单的表格、一个哈希表或者其它任何形式，映射由内核代码针对某一特定的文件系统实现和管理。从概念上讲，一个目录可以被视为任何普通的文件，唯一的不同点是它仅仅存储名字和inode的映射。内核直接使用这个映射将文件名解析为inode。

当用户空间应用请求打开一个指定的文件时，内核打开包含指定文件名的目录，然后搜索该文件。内核根据文件名获取inode编号，然后根据inode编号中找到对应的inode。inode包含了文件相关的元数据，其中包括文件数据在磁盘上的存储位置。


最初，磁盘上只有根目录，这个目录通常标记为/。但我们所知道的是，系统上有很多目录。那么内核怎么知道该到哪一个目录查找给定的文件名呢？

如同之前所述，目录和普通文件相似，事实上，它们甚至也有关联的inode。因此，目录内的链接能够指向别的目录的inode。这也意味着目录可以嵌套到别的目录中，形成目录层次。这样就允许使用所有Unix用户都熟悉的路径名来查找文件，如/home/blackbeard/landscaping.txt.

当内核打开类似的路径名时，它通过遍历路径上的每一个目录项（directory entry，在内核中称为dentry）来查找下一项的inode。在前面的例子中，内核从/开始，获取home的inode，跳转到那，然后获取 blackbeard的inode，再进入该项，最终找到landscaping.txt的inode。这个操作过程称为目录或者路径解析。内核也使用缓存（称为dentry cache）来存储目录解析的结构，提供时间局部性支持，加快查询速度。时间局部性支持，我们将在后续章节讨论。

一个从根目录开始的路径名称为完全指定（fully qualified）的，也叫做绝对路径。一些路径并不是完全指定的，相反，它们只是相对于其它目录（例如：todo/plunder)。这些路径称为相对路径。当遇到相对路径时，内核在当前的工作目录下进行路径解析。从当前工作目录开始，内核首先查找目录todo，从那里内核获取plunder的 inode。

虽然目录可以看成是普通的文件，但是内核不允许像操作普通文件一样打开和操作它们。相反，它们必须通过几个特殊的系统调用来操作它们，不管在什么情况下，这些调用仅允许进行两个操作：添加链接和删除链接。如果允许用户空间绕过内核的管理而进行目录操作，那么一个非常简单的错误都可能导致文件系统崩溃。

\subsubsection{硬链接}

从概念上看，到目前为止还没有任何内容涉及防止多个名字解析到同一个inode上。事实上，这样做是可以的。我们把将不同名字映射到同一个indoe信息节点的多个链接称为硬链接。

在复杂的文件系统结构中，硬链接允许多个路径名指向相同的数据。硬链接可以在同一个目录下，也可以在不同的目录中，无论在哪种情况下，内核完全可以将路径名解析到正确的信息节点上。例如，/home/bluebeard/map.txt 和/home/blackbeard/treasure.txt 都可以硬链接到指定的inode上。

删除目录结构中的一个文件将会引发一个unlink操作，该操作将文件名和inode的映射信息从目录中移除。然而，因为Linux支持硬链接，文件系统不能在每一次unlink操作都移除inode以及和它关联的数据。如果在文件系统别的地方存在另一个硬链接怎么办?为了保证每个文件在所有的链接都移除后才彻底删除文件，每个inode还包含一个链接计数(link count)来跟踪文件系统中指向该文件的硬链接数目。当路径名解除链接，链接计数将减1。当它为0的时候，inode和它关联的数据才正真的从文件系统中删除。

\subsubsection{符号链接}

因为inode编号在自己文件系统之外没有任何意义，所以不能跨文件系统建立链接。为了允许跨越文件系统建立链接，Unix系统还实现了符号链接（通常简称为symlinks）。

符号链接看上去像普通文件，每个symlink都有自己的inode和包含被链接文件完整路径名的数据块。这意味着符号链接可以指向任何地方，包括不同文件系统上的文件和目录，甚至不存在的文件和目录。指向不存在文件的符号链接称为坏链接。

相比硬链接，符号链接解析需要更多开销。因为有效的解析符号链接需要解析两个文件：符号链接和被链接的文件。硬链接不需要额外的开销，因为一次或多次进入文件系统访问被链接的文件并没有任何区别。尽管符号链接的解析的开销不大，但仍然被认为是消极的。

相比硬链接，符号链接缺少一定的透明性。使用硬链接是完全透明的，实际操作中，它需要找出被链接文件是否被多次链接。而操作符号链接需要特殊的系统调用。符号链接作为一种文件访问的快捷方式而不是文件系统内部链接时，这种透明性的缺乏也具有一定的积极意义。

\subsubsection{特殊文件}

特殊文件是以文件方式表示的内核对象。一直以来，Unix系统支持了一些不同的特殊文件，Linux支持四种类型的特殊文件：块设备文件、字符设备文件、命名管道和Unix域套接字。特殊文件是将某些抽象融入文件系统的一种方法，是一切皆文件理念的实践。Linux提供了创建特殊文件的系统调用。

对Unix系统的设备进行访问通过设备文件来实现，设备文件的表现和特征和文件系统中的普通文件一样。设备文件可以被打开、读取和写入，以此允许用户空间程序访问和操作系统上的（物理和虚拟的）设备。Unix的设备通常分为两类：字符设备和块设备。每种设备类型都有自己的专用设备文件。

访问字符设备如同访问字节线性队列。设备驱动程序将字节按序写入队列，用户空间程序则按照字节被写入队列的顺序进行读取。键盘就是典型的字符设备。如果你敲入"peg"，应用程序将从键盘设备中读取p，然后是e，最后是g。当没有更多的字符需要读取时，设备返回end-of-file（EOF）。漏读数据或者以任何其它的顺序读取都没有意义。字符设备通过字符设备文件(character device file)进行访问。

相比之下，块设备则不同，它以字节数组的方式进行访问。设备驱动将字节映射到可寻址的设备上，用户空间可以自由的以任何顺序访问数组中的任何字节，你可以读取字节12，字节7然后再读字节12。块设备通常是存储设备、硬盘、软盘、CD-ROM驱动器和闪存都是典型的块设备，它们通过块设备文件(block device files)进行访问。

命名管道（通常叫FIFOs，是“先进先出”的简称）是一种以文件描述符为信道的进程间通信(IPC)机制，通过一种特殊文件进行访问。普通管道是将一个程序的输出以“管道”的方式传送给另一个程序，并做为该程序的输入。它们通过系统调用在内存中创建而不在任何文件系统中存在。命名管道和普通管道一样，但是通过文件进行访问。称为FIFO特殊文件，不相关的进程也可以访问这个文件而进行交互。

套接字是最后一种类型的特殊文件。套接字是进程间通信中的高级形式，它允许不同进程进行通信，不仅仅是同一台机器，不同机器也可以。事实上，套接字是网络和因特网编程的基础。它们演化出多个变种，包括Unix域套接字，这是本地机器进行交互的套接字格式。相比网络上的套接字交互需要通过主机名和端口对来确定交互的目标，Unix域套接字使用文件系统上的特殊文件进行交互，该文件称为套接字文件。

\subsubsection{文件系统和名字空间}

如同所有的Unix系统一样，Linux提供了一个全局统一的文件和目录的名字空间。某些操作系统将磁盘和驱动器分割成独立的名字空间。例如，软盘上的文件可能通过A:\textbackslash plank.jpg文件名进行访问，而硬盘位置为C:\textbackslash。在Unix中，同样在软盘上的文件则通过/media/floppy/plank.jpg或者/home/captain/stuff/plank.jpg来访问，它和其它介质中的文件是在同一个名字空间下的。也就是说，在Unix中的命名空间是统一的。

文件系统是以合法层次结构组织的文件和目录的集合。文件系统能从全局的文件和目录的名字空间独立的添加和移除。这些操作称为挂载（mounting）和卸载(unmounting)。每个文件系统都要挂载在名字空间中特定的位置，这个位置称为挂载点。文件系统的根目录可以通过挂载点访问。例如，挂载CD到/media/cdrom，然后就可以通过访问挂载点来访问CD上的文件系统的根目录。第一个被挂载的文件系统位于名字空间的根部/，称为根文件系统。Linux系统总有一个根文件系统。除此之外，可在其它的挂载点挂载其它的文件系统。

文件系统一般来讲是存在于物理介质上的（如存在磁盘上），同时Linux也支持存储在内存上的虚拟文件系统和跨网络的网络文件系统。物理文件系统存在于如CD、软盘、闪存或者硬盘等块存储设备。其中一些设备是可分区的，这意味着它们可以切分成多个独立操作的文件系统。Linux支持大部分的文件系统(包含了大部分用户所希望的文件系统)，例如媒体文件系统（media-specific filesystems）（如ISO9660），网络文件系统（NFS），原生文件系统（ext3），其它Unix系统的文件系统（XFS）以及非 Unix文件系统（FAT）。

块设备最小访问地址单元为扇区，扇区是设备的物理单位。扇区一般是2的指数倍，通常为512字节。块设备无法转移或者访问比扇区更小的数据单元。所有的I/O操作都发生在一个或多个扇区上。

同样，文件系统中最小的逻辑地址单元是块，块是文件系统中的抽象 而不是对物理介质的抽象，块通常是2的指数倍与扇区大小的乘积。块一般大于扇区的大小，但是必须小于页的大小（最小可访问的内存管理单元，一个硬件部件）。普通块大小为512B，1KB和4KB。

从历史的角度讲，Unix系统仅有单一共享命名空间，系统上所有的进程和用户都可见。Linux另辟蹊径，支持进程独立的名字空间，允许每一个进程拥有一个系统文件和目录层次的唯一视图。默认情况下，子进程继承父进程的名字空间，但是一个进程可以通过选择一系列挂载节点和独立的根目录来创建自己的名字空间。

\subsection{进程}

如果说文件是Unix系统最重要的抽象概念，那么进程仅次于文件。进程是执行中的目标代码：活动的、生存的、运行的程序。除了目标代码，进程还包含数据、资源、状态以及虚拟化的计算机。

进程从可执行目标代码开始其生命周期。这些目标代码具有内核能够解析的可执行格式（Linux下最常用的格式是ELF），且可以由机器执行。可执行格式代码包含有元数据，多个代码和数据段。“段”是加载到线性内存块的线性目标代码块。所有片段内的字节将一视同仁，赋予相同的权限，一般也用于同样的目的。

最重要和通用的段莫过于代码段，数据段和bss段。代码段包含可执行代码和只读数据，如常量，经常标记为只读和可执行。数据段包含已初始化的数据，如定义了值的C变量，通常标记为可读写的。bss段包含未初始化的全局数据，因为C标准规定C变量的默认值全为0，因此没有必要在磁盘上的目标代码中保存这些0。相反，目标代码可以简单的列举bss段中未初始化的变量，内核将映射0页面（全0的内存页）到那个加载进内存的段，为了优化性能人们设计了bss段。这个名称带有几分历史痕迹，它是block started by symbol，或者block storage segment的缩写。其它ELF中可执行的通用段都是绝对地址段（absolut section）（包含不可再定位符号）和未定义段（容器）。

一个进程还和由内核仲裁和管理的系统资源关联，进程典型的资源请求和操作只能通过系统调用。资源包括计时器，挂起信号量、打开文件，网络连接，硬件和进程通信。一个进程的资源，进程相关的数据和统计信息都存储在内核中该进程的进程描述符中。

进程是一种虚拟的抽象。Linux内核支持抢占式多任务和虚拟内存，它给进程提供了虚拟处理器和内存的虚拟视图。从进程的视角看，系统完全由该进程控制。也就是说，尽管给定的进程和其它的进程共用调度，但是看起来好像它在独立控制整个系统。系统将无缝透明的重新进行进程调度，将系统的处理器和所有进程共享，而进程不会感到区别。类似的，每一个进程获得一个独立的线性地址空间，就像它独立控制整个系统内存。通过虚拟内存和分页调度，内核允许多个进程共存在系统上，每个进程操作都有自己的地址空间。内核通过现代处理器的硬件支持来管理这种虚拟化，它使得操作系统能够并发管理多个独立的进程。

\subsubsection{线程}

一个进程包含一个或多个执行线程（通常只叫线程），线程是进程中的活动单位。线程是一种抽象，它负责执行代码和维护进程的运行状态。

大部分进程只包含一个线程，它们被称为单线程的（single-thread），包含多个线程的进程称为多线程的（multithreaded）。从传统上讲，因为Unix保持简洁、期望加快进程创建时间、保持健壮的进程通信机制，这些都减少了对线程的需求。可以说，Unix程序被单线程化了。

线程包括栈（如同在非线程系统上的进程栈，主要用于存储局部变量)、处理器状态、目标代码的当前位置（通常是处理器的指令指针）。进程剩下的部分由所有线程共享。

Linux内核实现了一个独特的线程视图：它们是偶然共享某些资源的（大多数情况下是一个地址空间）进程。在用户空间，Linux根据 POSIX1003.1c实现线程（pthread）。目前Linux线程实现的名称为Native POSIX Threading Library（NPTL）是glibc库的一部分。

\subsubsection{进程体系}

每一个进程都由一个唯一的正整数标识，即进程ID（pid）。第一个进程的pid是1，接下来每一个进程接受一个新的唯一的pid。

在Linux中，进程有一个严格的层次结构，这就是广为人知的进程树。进程树以第一个进程，也就是init进程(一般是init（8）程序)为根。新进程通过 fork（）系统调用创建。fork（）复制了调用进程，而原进程称为父进程，新进程称为子进程。除了第一个进程外，每一个进程都有父进程。如果父进程在先于子进程终止，内核将init进程指定为它的父进程。

如果进程终止，它并不会立即从系统中移除。相反，内核将在内存中保存进程的部分内容，允许父进程查询该进程终止的状态，这被称为终止进程等待。一旦父进程已经确认它的终止的子进程，子进程就完全的删除了。如一个进程已经终止，但父进程尚未获知它的状态，则称为僵尸进程(zombie)。 init进程等待其所有的子进程，保证它的子进程不会永久处于僵死状态。

\subsection{用户和组}

Linux中通过用户和组进行认证。每个用户和唯一的正整数关联，称为用户ID（uid）。每一个进程与一个用户ID关联，用来识别运行这个进程的用户，一般称为进程的真实uid(real uid)。在Linux内核中，uid是用户的唯一标识。但用户一般都是通过用户名而不是数字id来指代自己或者其它用户。用户名和它们对应的用户id存储在/etc/passwd中，而库例程将其用户名映射到相应的uid上。

在登陆的过程中，用户向login(1)程序提交用户名和密码。如果提供的用户名和密码都正确，login(1)程序将根据/etc/passwd为用户生成一个登陆shell(login shell)，并将用户id作为进程的uid。子进程继承父进程的uid。

uid 0 是超级用户root的用户id。 超级用户拥有做任何事情的特权，例如只有root用户有权限修改进程的uid。因此，login(1)的用户为超级管理员。

除了真实UID(real uid)之外，每个进程有一个有效UID(effective uid)，一个保留uid(saved uid)和文件系统uid(filesystem uid)。 真实UID(real uid)是启动进程的用户，有效UID(effective uid)可以使进程在其它用户的权限下运行，保留uid(saved uid)保存原来的有效UID(effective uid)，它的值决定了用户将切换到哪个有效UID(effective uid)中。文件系统uid通常和有效UID(effective uid)相等，用来检测文件系统的访问权限。

每一个用户都归属于一个或者多个组，包括列在/etc/passwd中的基本组（primary group）或登录组（login group），也可能是/etc/group中其它附加组。 每一个进程因此也有一个组ID(gid)，因此也有真实gid(real gid)，有效gid(effective gid)，保留gid(saved gid)以及文件系统gid(filesystem gid)。进程和用户登入组关联，和其它附加组没有关系。

一些安全机制只允许进程在满足特定权限时才能进行某些操作。传统的Unix的原则非常简单：uid为0的进程可以访问的资源，其它的进程都不可访问。近来，Linux采用了更有效率的机制来代替传统的安全机制，它取消了简单的二元判断方式，允许内核进行更细粒度的访问控制设置。

\subsection{权限}

Linux上的标准文件权限和安全机制与Unix一致。

每一个文件都有一个所有者，所属组以及权限位集。这些位描述了所有者、所属组以及其它人对文件进行读、写和执行的权限。这三类每一个对应三个位，共9位。 文件所有者和权限信息存储在文件的indoe中。

对于普通文件，权限是很显然的，它们已经清楚表明读文件，写文件和执行文件的权限。虽然特殊文件实际读和写的内容由特殊文件自己确定，但是特殊文件上的读和写权限与普通文件的一样，执行权限在特殊文件上被忽略。目录的读权限是允许目录中的内容被列出，写权限允许在目录中添加新的链接，执行权限允许目录进入和使用该路径。 表格1-1列出了9个权限位，它们的8进制值（常用的9位表示方式），文本值（如ls显示的结果），还有对应的含义。
\begin{flushleft}
表格1-1 权限位及其值
\end{flushleft}
\begin{flushleft}
\begin{tabular}{p{2cm}p{2.8cm}p{2.8cm}p{3.0cm}}\toprule
\rowcolor[gray]{.9}
 \textbf{位} & \textbf{八进制值} & \textbf{文本值} & \textbf{对应权限}\\ \midrule
 \textbf 8 & 400 & r-------- & 所有者可读 \\ 
 \textbf 7 & 200 & -w------- & 所有者可写 \\ 
 \textbf 6 & 100 & --x------ & 所有者可执行 \\ 
 \textbf 5 & 040 & ---r----- & 组用户可读 \\ 
 \textbf 4 & 020 & ----w---- & 组用户可写 \\ 
 \textbf 3 & 010 & -----x--- & 组用户可执行 \\ 
 \textbf 2 & 004 & ------r-- & 所有用户可读 \\ 
 \textbf 1 & 002 & -------w- & 所有用户可写 \\ 
 \textbf 0 & 001 & --------x & 所有用户可执行 \\ 
 \end{tabular}
 \end{flushleft}
除了Unix的权限外，Linux还支持访问控制表（ACLs），ACLs支持更多细节、确切权限及安全控制，只是增加了管理复杂性和磁盘存储的开销。

\subsection{信号}

信号是一种单向异步通知机制，信号可能是从内核发送到进程，也可能是从进程到进程，或者进程给自己。信号一般用于通知进程发生某些事件，如段错误或者用户输入Ctrl+C。

Linux内核实现了大约30个信号（实际的数字由架构决定），每一个信号由一个数字常量和文本名表示。例如，SIGHUP用于表示终端挂起，在i386上的值为1.

除了SIGKILL（进程中断）和SIGSTOP（进程停止）外，进程能够根据接收到的信号进行控制。它们可以使用默认的信号处理操作，可能是中断进程、中断并做内存信息转储（coredump）、停止进程，或者什么也不做，具体的操作取决于信号值。另外，进程可以选择显式的忽略或者处理信号。忽略信号是将信号丢弃，不做处理。处理信号将执行用户编写的信号处理函数，程序将在接收到信号时跳到处理函数，信号处理程序返回后，将把程序控制权回交给原来的程序，在之前中断的指令处继续执行。

\subsection{进程间通讯}

允许进程交换信息和通知彼此所发生的事件是操作系统最重要的工作之一。Linux内核实现了传统的Unix的进程间通讯（IPC）机制，包括System V和POSIX共同定义和标准化的机制，以及Linux自定义的机制。

Linux支持的进程间通讯机制包括管道，命名管道，信号量，消息队列，共享内存和快速用户空间互斥体（Futexes）。

\subsection{头文件}

Linux系统编程离不开大量的头文件。内核和glibc为系统级编程提供了头文件。这些头文件包括标准C库（例如,<string.h>）以及Unix的一些贡献（如：<unistd.h>）。

\subsection{错误处理}

不用说，检测和处理错误是极其极其重要的。在系统编程中，错误通常通过函数的返回值表示，并通过特殊的变量errno来描述。glibc对库函数和系统调用的errno提供透明支持。本书所提及的大量接口都使用这个机制来报告错误。

函数通过特殊的返回值（通常是-1，具体值取决于函数），来通知调用者所发生的错误。错误值告诉调用函数发生了错误，但是不提供发生错误的原因，errno变量用于定位错误的原因。


该变量在<errno.h>中定义如下：

extern int errno;

erron的值仅仅在errno设置函数显示错误后（通常返回-1）短时间有效,否则，任何后续成功执行的函数都可以修改其值。

errno值可以直接被读写，它是可修改的左值（lvalue）。errno的值与指定错误的文本信息一一对应。预处理器\#define同样将errno映射到相应的数字值上。如，预处理器定义EACCESS等于1，表示“权限不足”，表格1-2上列举了标准定义和与错误相匹配的文字描述。

\begin{flushleft}
表格 1-2 错误代码及其描述
\end{flushleft}
\begin{flushleft}
\begin{tabular}{ccc}
\toprule [1pt]
\rowcolor[gray]{.9}
\textbf{预处理器定义}&\textbf{描述}\\
\midrule
E2BIG&参数列表太长\\
EACCESS&权限不足\\
EAGAIN&重试\\
EBADF&文件号错误\\
EBUSY&设备或资源忙\\
ECHILD&无子进程\\
EDOM&数学参数不在函数域内\\
EEXIST&文件已存在\\
EFAULT&地址错误\\
EFBIG&文件太大\\
EINTR&系统调用被中断\\
EINVAL&参数无效\\
EIO&I/O错误\\
EISDIR&是目录\\
EMFILE&打开文件太多\\
EMLINK&太多链接\\
ENFILE&文件表溢出\\
ENODEV&无此设备\\
ENOENT&无此文件或目录\\
ENOEXEC&执行格式错误\\
ENOMEM&内存用尽\\
ENOSPC&设备无剩余空间\\
ENOTDIR&非目录\\
ENOTTY&不合理I/O控制操作\\
ENXIO&无此设备或地址\\
EPERM&操作不允许\\
EPIPE&管道损坏\\
ERANGE&结果范围太大\\
EROFS&只读文件系统\\
ESPIPE&非法定位\\
ESRCH&无此进程\\
ETXTBSY&文本文件忙\\
EXDEV&跨文件系统链接\\
\bottomrule[1pt]
\end{tabular}
\end{flushleft}

C库提供了一些函数将errno值转换到对应的文本。这些函数仅仅在错误报告时是有必要的，检查错误和处理错误操作则可以直接使用预处理器定义和errno进行处理。

第一个这样的函数是perror():

\begin{lstlisting}
#include <stdio.h>
void perror(const char *str);
\end{lstlisting}

这个函数向stderr（标准错误输出）打印出以str指向的字符串为前缀，中间一个冒号，然后是errno描述的当前错误所陈述的字符串。为了使输出错误更加有用，执行失败的函数的名称最好包含在该字符串中，例如：

\begin{lstlisting}
if (close (fd) == -1)
        perror ("close");
\end{lstlisting}

C库还提供了streeor()和strerror\_r(),原型如下：

\begin{lstlisting}
  #include <string.h>
  char * strerror (int errnum);
\end{lstlisting}

和
\begin{lstlisting}
  #include <string.h>
  int strerror_r(int errnum, char *buf, size_t len);
\end{lstlisting}

前一个函数返回errnum值描述的错误的字符串指针。字符串不能被应用程序修改，但是可以被接下来的perror()和streeror()函数所修改。这些方法都不是线程安全(thread-safe)的。

strerror\_r()函数是线程安全的，它向buf指向的长度为len的缓冲区写入数据。streeror\_r()在成功时返回0，失败时返回-1，具有讽刺意味的是，这个函数也在错误时设置errno。

对于某些函数，在返回类型的范围内的值都是合法的返回值。在这种情况下，errno必须在调用前被设定为0，且调用后进行检测（这些函数约定在真正发生错误时只返回非0值）。例如

\begin{lstlisting}
  errno = 0;
  arg = strtoul (buf, NULL, 0);
  if (errno)
  perror ("strtoul");
\end{lstlisting}

使用errno时常犯的错误是忘记库函数和系统调用都可以修改errno。例如，以下代码是有问题的：

\begin{lstlisting}
  if (fsync (fd) == -1) {
    printf (stderr, "fsync failed!\n");
    if (errno == EIO)
    fprintf (stderr, "I/O error on %d!\n", fd);
  }
\end{lstlisting}

如果你需要跨函数调用来保留errno的值，你需要保存该值：

\begin{lstlisting}
  if (fsync (fd) == -1) {
    int err = errno;
    fprintf (stderr, "fsync failed: \n", strerror (errno));
    if (err == EIO) {
      /* if the error is I/O-related, jump ship */
      fprintf (stderr, "I/O error on %d!\n", fd);
      exit (EXIT_FAILURE);
    }
  }
\end{lstlisting}

如本节前面所介绍的，在单线程程序中，errno是全局变量。然而，在多线程程序中，每一个程序都保留了自己的errno，因此是线程安全的。 

\section{开始系统编程}
这一章着眼于Linux系统编程的基础并展示了程序员角度的Linux系统。下一章将讨论文件I/O。当然，这包括读和写文件；然而，因为Linux实现了很多文件相关的接口，文件I/O，怎么说，比文件重要的不只是一点点。

依靠之前这些知识，然后从广阔的视角上收缩下来，是的，是时候进行真正的系统编程了。动手吧，朋友们。 
